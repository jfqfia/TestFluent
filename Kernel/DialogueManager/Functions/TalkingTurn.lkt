// **************************************************
//
//	
//
// **************************************************
//
//	PROJECT	:	
//	MODULE  :	
//	PACKAGE :	
//	FILE	:	
//
// **************************************************

procedure startTalkingTurn()
{
	initMindBoardOutput();
}

procedure digestSearchScripts()
{
	ProferenceChunk proference;

	DigestSchemes emptyDigestSchemes;
	DialogueScripts dialogueScripts;
	DialogueScript dialogueScript;
	ScriptTriggerComponent scriptComponent;

	// TODO VERY CAREFUL HERE: This is the only way of clearing DialogueDigest feature
	$MINDBOARD@DialogueDigest.DigestSchemes <- emptyDigestSchemes;

	SpyMessage("===============================================");
	SpyMessage("XXXX: digestSearchScripts - START");

	int profSize <- BatchSize( $MINDBOARD@DialogueInput.ProferenceChunks );
	for( int profPosition <- 1; profPosition <= profSize; profPosition++ ) 
	{
		BatchRecoverPosition( $MINDBOARD@DialogueInput.ProferenceChunks, profPosition, proference );

		dialogueScripts <- $MINDBOARD@DialogueScheme.DialogueScripts;
		int scriptSize <- BatchSize( dialogueScripts );
		for (int scriptPosition <- 1; scriptPosition <= scriptSize; scriptPosition ++ ) 
		{
			BatchRecoverPosition( dialogueScripts, scriptPosition, dialogueScript );
			
			scriptComponent <- getCompatibleScriptTriggerComponent( dialogueScript, proference );
			if( Filled(scriptComponent) )
			{
				insertDigestScheme(dialogueScript.ScriptDescriptor, proference, scriptComponent);
			}
		}
	}

	// TODO QUITAR
	SpyMessage($MINDBOARD@DialogueDigest);
	SpyMessage("XXXX: digestSearchScripts - END");
	SpyMessage("===============================================");
}

procedure activateScripts()
{
	int size;

	// TODO
	// We must look here the DialogueDigest structure and choose between them
	// Actually we choose last one...
	size <- BatchSize( $MINDBOARD@DialogueDigest.DigestSchemes );

	// What to do if there is no searched script
	if(size > 0)
	{
		DigestScheme digestScheme;
		BatchRecoverPosition( $MINDBOARD@DialogueDigest.DigestSchemes, size, digestScheme );
		BatchInsertEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, digestScheme.ScriptDescriptor );	
	}

	// TODO
	// Actually we only set, as current script, the last of the ActivatedScriptsStack batch
	string scriptDescriptor;

	size <- BatchSize( $MINDBOARD@DialogueState.ActivatedScriptsStack );
	BatchRecoverPosition( $MINDBOARD@DialogueState.ActivatedScriptsStack, size, scriptDescriptor );

	$MINDBOARD@DialogueState.CurrentScriptDescriptor <- scriptDescriptor;
}

procedure selectCurrentNode()
{
	DialogueScript dialogueScript;
	ScriptNodeDescriptor nodeDescriptor;
	int size;
	int position;
	ActivatedScriptNodes activatedScriptNodes;
	ScriptNode node;

	dialogueScript <- getCurrentScript( );
	size <- BatchSize( dialogueScript.ScriptNodes );
	for(position <- 1; position <= size; position++) 
	{
		BatchRecoverPosition( dialogueScript.ScriptNodes, position, node );
		if( preconditionsValidated(node) )
		{ 
			BatchInsertEnd( activatedScriptNodes, node.ScriptNodeDescriptor );
		}
	}

	dialogueScript.ActivatedScriptNodes <- activatedScriptNodes;

	// TODO
	// Define activated nodes policy
	// Here we select last node as current
	// It would be better to select randomly the next node

	size <- BatchSize( activatedScriptNodes );
	if( size > 0 )
	{
		BatchRecoverPosition( activatedScriptNodes, size, nodeDescriptor );
		dialogueScript.CurrentNodeDescriptor <- nodeDescriptor;
	}
	else
	{
		dialogueScript.CurrentNodeDescriptor <- '';
	}

	setScript( dialogueScript );
}

procedure processTellNode()
{
	ScriptNode currentNode;

	currentNode <- getCurrentNode();

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, 
			currentNode.ScriptNodeContent.DialogueAct );

	executePostconditions( currentNode );
}

procedure processExecuteNode()
{
	ScriptNode currentNode;

	currentNode <- getCurrentNode();

	executePostconditions( currentNode );
}

procedure processWaitNode()
{
	ScriptNode currentNode;

	currentNode <- getCurrentNode();

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, 
			currentNode.ScriptNodeContent.DialogueAct );

	executePostconditions( currentNode );
}

procedure closeTalkingTurn()
{
	initMindBoardInput();
}




