// **************************************************
//
//	
//
// **************************************************
//
//	PROJECT	:	
//	MODULE  :	
//	PACKAGE :	
//	FILE	:	
//
// **************************************************

// Devuelve cierto si el actual es dialogueScript y además es un desambiguador
// Se llama desde DigestPhases (getCompatibleScriptTriggerComponent)
bool isCurrentAndDisambiguator(DialogueScript dialogueScript)
{
	DialogueScript current <- getCurrentScript();
	if(current.ScriptDescriptor == dialogueScript.ScriptDescriptor)
	{
		if( isDisambiguator(dialogueScript) )
		{
			return True;	
		}
	}

	return False;
}

bool isDisambiguator(DialogueScript dialogueScript)
{
	return SubLiteral(dialogueScript.ScriptDescriptor, 1, 14) == 'disambiguator_';
}

procedure pushWeakDisambiguator(int size, bool nextToBeActivated)
{
	DialogueScript dialogueScript;
	
	dialogueScript <- createWeakDisambiguator(size, nextToBeActivated);

	BatchInsertEnd( $MINDBOARD@DialogueScheme.DialogueScripts, dialogueScript );
	BatchInsertEnd( $MINDBOARD@WorkingDialogueScheme.DialogueScripts, dialogueScript );
	BatchInsertEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, dialogueScript.ScriptDescriptor );
}

procedure pushStrongDisambiguator(int size, bool nextToBeActivated)
{
	DialogueScript dialogueScript;
	
	dialogueScript <- createStrongDisambiguator(size, nextToBeActivated);

	BatchInsertEnd( $MINDBOARD@DialogueScheme.DialogueScripts, dialogueScript );
	BatchInsertEnd( $MINDBOARD@WorkingDialogueScheme.DialogueScripts, dialogueScript );
	BatchInsertEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, dialogueScript.ScriptDescriptor );
}

DialogueScript createWeakDisambiguator(int size, bool nextToBeActivated)
{
	// Script Descriptor
	DialogueScript dialogueScript;
	string scriptDescriptor <- '';
	scriptDescriptor <- LiteralConcat(scriptDescriptor, 'disambiguator_' );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, 'weak_' );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, ShapeToString(size) );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, '_' );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, ShapeToString(BatchSize($MINDBOARD@DialogueState.ActivatedScriptsStack)) );
	if(nextToBeActivated)
	{
		scriptDescriptor <- LiteralConcat(scriptDescriptor, 'T' );
	}
	else
	{
		scriptDescriptor <- LiteralConcat(scriptDescriptor, 'F' );
	}
	dialogueScript.ScriptDescriptor <- scriptDescriptor;

	// Info
	ScriptInfoItem scriptInfoItem, emptyScriptInfoItem;

	int activatedSize <- BatchSize($MINDBOARD@DialogueState.ActivatedScriptsStack);
	for(int position <- activatedSize - size + 1; position <= activatedSize; position++)
	{	
		BatchRecoverPosition($MINDBOARD@DialogueState.ActivatedScriptsStack, position, scriptDescriptor);

		DialogueScript recoveredDialogueScript <- getScript( scriptDescriptor );

		scriptInfoItem <- emptyScriptInfoItem;
		scriptInfoItem.InfoItemType <- 'action';	
		scriptInfoItem.InfoItemState <- 'empty';	
		scriptInfoItem.InfoItemValue.ActionDomain <- searchActionDomainInTriggerScript(recoveredDialogueScript);
		BatchInsertEnd( dialogueScript.ScriptInfoItems, scriptInfoItem );

		scriptInfoItem <- emptyScriptInfoItem;
		scriptInfoItem.InfoItemType <- 'scope';	
		scriptInfoItem.InfoItemState <- 'empty';	
		scriptInfoItem.InfoItemValue.Scope <- searchScopeInTriggerScript(recoveredDialogueScript);
		BatchInsertEnd( dialogueScript.ScriptInfoItems, scriptInfoItem );
	}

	// Node - AskChoices
	ScriptNode nodeAskChoices <- createScriptNode( 'askchoices', 'wait', 1 );
	nodeAskChoices.ScriptNodeContent <- setNodeContent( 'question', 'choice', '', '' );
	BatchInsertEnd( nodeAskChoices.ScriptNodePreconditions, createNegatedPrecondition2Arguments( 'is_node_state', 'askchoices', 'finalized' ));
	BatchInsertEnd( nodeAskChoices.ScriptNodePostconditions, createDialogueAction0Arguments( 'generate_wd_choices' ));	
	BatchInsertEnd( nodeAskChoices.ScriptNodePostconditions, createDialogueAction2Arguments( 'set_node_state', 'askchoices', 'finalized' ));	

	BatchInsertEnd( dialogueScript.ScriptNodes, nodeAskChoices );

	// Node - MakeChoices
	ScriptNode nodeMakeChoices <- createScriptNode( 'makechoices', 'execute', 2 );
	BatchInsertEnd( nodeMakeChoices.ScriptNodePreconditions, createNegatedPrecondition2Arguments( 'is_node_state', 'makechoices', 'finalized' ));
	BatchInsertEnd( nodeMakeChoices.ScriptNodePostconditions, createDialogueAction0Arguments( 'make_wd_choices' ));	
	BatchInsertEnd( nodeMakeChoices.ScriptNodePostconditions, createDialogueAction2Arguments( 'set_node_state', 'makechoices', 'finalized' ));	

	BatchInsertEnd( dialogueScript.ScriptNodes, nodeMakeChoices );

	return dialogueScript;
}

procedure makeWeakDisambiguatorChoices()
{
	int maxScore <- 0;
	int maxPosition;

	ScriptInfoItem scriptInfoItem1, scriptInfoItem2;
	DialogueAct dialogueAct, emptyDialogueAct;
	DialogueScript script <- getCurrentScript();
	
	int size <- BatchSize(script.ScriptInfoItems);
	int position;
	for(position <- 1; position <= size; position <- position + 2)
	{
		BatchRecoverPosition( script.ScriptInfoItems, position , scriptInfoItem1 );
		BatchRecoverPosition( script.ScriptInfoItems, position + 1, scriptInfoItem2 );				

		int currentScore <- 0;
		if(scriptInfoItem1.InfoItemState == 'captured')
		{
			currentScore <- currentScore + 1;
		}
		if(scriptInfoItem2.InfoItemState == 'captured')
		{
			currentScore <- currentScore + 2;
		}
		if(currentScore >= maxScore)
		{
			maxScore <- currentScore;
			maxPosition <- (position + 1) / 2;
		}
	}
	int numChoices <- position / 2;

	// Detect ordinals in not digested proferences zone (when they are implemented)
	if(maxScore == 0 && hasBeenOrdinal())
	{
		Ordinal ordinal <- getLastOrdinal();

		if(!! ordinal.OrdinalReverseFlag)
		{
			maxPosition <- ordinal.NumberValue;
		}
		else
		{
			maxPosition <- numChoices - ordinal.NumberValue + 1;
		}

		if(maxPosition >= 1 && maxPosition <= numChoices)
		{
			maxScore <- 1;
		}
	}

	if(maxScore == 0)
	{
		dialogueAct <- emptyDialogueAct;
		dialogueAct.CoreDialogueAct.Dimension <- 'social';
		dialogueAct.CoreDialogueAct.Function <- 'apology';
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'not' );
		dialogueAct.TaskDialogueAct.Scope <- 'understand';
		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

		string descriptor;
		BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
		DialogueScript recoveredDialogueScript <- removeFromWorkingDialogueScheme( descriptor );

		for(position <- 1; position <= numChoices; position++ )
		{
			BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
			recoveredDialogueScript <- removeFromWorkingDialogueScheme( descriptor );
				
			recoveredDialogueScript <- getFromOriginalDialogueScheme( descriptor );
			BatchInsertEnd( $MINDBOARD@WorkingDialogueScheme.DialogueScripts, recoveredDialogueScript );
		}
	}
	else
	{
		// Pull own script
		string descriptor;
		BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
		DialogueScript recoveredDialogueScript <- removeFromWorkingDialogueScheme( descriptor );

		// pull the script in maxPosition
		ActivatedScriptsStack choices;
		ScriptDescriptor selectedScriptDescriptor;
		for(int i <- 1; i <= numChoices; i++)
		{
			BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
			if(i == numChoices + 1 - maxPosition)
			{
				selectedScriptDescriptor <- descriptor;
			}
			else
			{
				BatchInsertInit(choices, descriptor);
			}
		}
		for(int i <- 1; i < numChoices; i++)
		{
			BatchExtractInit( choices, descriptor );
			BatchInsertEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
		}

		// insert another weak disambiguator if necessary
		if( numChoices > 2 )
		{
			pushWeakDisambiguator(numChoices - 1, False);
		}

		// push to the top the script in maxPosition
		BatchInsertEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, selectedScriptDescriptor );
	}
}

Ordinal getLastOrdinal()
{
	bool found <- False;
	Ordinal ret;
	ProferenceChunk proference;

	int size <- BatchSize( $MINDBOARD@DialogueState.NotDigestedProferenceChunks );
	for( int position <- size; position >= 1 && !! found; position-- )
	{
		BatchRecoverPosition( $MINDBOARD@DialogueState.NotDigestedProferenceChunks, position, proference );
		if( proference.Parameter.ParameterType == 'ordinal' )
		{
			ret <- proference.Parameter.ParameterValue.Ordinal;
			found <- True;
		}
	}

	return ret;
}

bool hasBeenOrdinal()
{
	bool ret <- False;
	ProferenceChunk proference;

	int size <- BatchSize( $MINDBOARD@DialogueState.NotDigestedProferenceChunks );
	for( int position <- 1; position <= size; position++ )
	{
		BatchRecoverPosition( $MINDBOARD@DialogueState.NotDigestedProferenceChunks, position, proference );
		if( proference.Parameter.ParameterType == 'ordinal' )
		{
			ret <- True;
		}
	}

	return ret;
}

procedure generateWeakDisambiguatorChoices()
{
	ScriptInfoItem scriptInfoItem1, scriptInfoItem2;
	DialogueAct dialogueAct, emptyDialogueAct;
	DialogueScript script <- getCurrentScript();
	
	if(LiteralPositionValue(script.ScriptDescriptor, LiteralSize(script.ScriptDescriptor)) == 'F')
	{
		dialogueAct <- emptyDialogueAct;

		dialogueAct.CoreDialogueAct.Dimension <- 'statement';
		dialogueAct.CoreDialogueAct.Function <- 'inform';
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'resume' );
		dialogueAct.TaskDialogueAct.Scope <- 'previousproference';

		dialogueAct.TaskDialogueAct.Scope <- 'Going back to what you said a moment ago. ';
		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );
	}
	
	dialogueAct <- emptyDialogueAct;

	dialogueAct.CoreDialogueAct.Dimension <- 'question';
	dialogueAct.CoreDialogueAct.Function <- 'whquestion';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'do' );
	dialogueAct.TaskDialogueAct.Scope <- 'first';

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

	int size <- BatchSize(script.ScriptInfoItems);

	for(int position <- 1; position <= size - 2 ; position <- position + 2)
	{
		BatchRecoverPosition( script.ScriptInfoItems, position , scriptInfoItem1 );
		BatchRecoverPosition( script.ScriptInfoItems, position + 1, scriptInfoItem2 );				

		dialogueAct <- emptyDialogueAct;
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'tell' );
		dialogueAct.TaskDialogueAct.Scope <- ', ';
		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

		dialogueAct <- emptyDialogueAct;
		dialogueAct.CoreDialogueAct.Dimension <- 'question'; 
		dialogueAct.CoreDialogueAct.Function <- 'choice';
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, scriptInfoItem1.InfoItemValue.ActionDomain );
		dialogueAct.TaskDialogueAct.Scope <- scriptInfoItem2.InfoItemValue.Scope;
		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );
	}

	BatchRecoverPosition( script.ScriptInfoItems, size - 1 , scriptInfoItem1 );
	BatchRecoverPosition( script.ScriptInfoItems, size, scriptInfoItem2 );				

	dialogueAct <- emptyDialogueAct;

	dialogueAct.CoreDialogueAct.Dimension <- 'statement';
	dialogueAct.CoreDialogueAct.Function <- 'inform';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'say' );
	dialogueAct.TaskDialogueAct.Scope <- 'or';

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

	dialogueAct <- emptyDialogueAct;
	dialogueAct.CoreDialogueAct.Dimension <- 'question'; 
	dialogueAct.CoreDialogueAct.Function <- 'choice';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, scriptInfoItem1.InfoItemValue.ActionDomain );
	dialogueAct.TaskDialogueAct.Scope <- scriptInfoItem2.InfoItemValue.Scope;
	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

	dialogueAct <- emptyDialogueAct;
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'tell' );
	dialogueAct.TaskDialogueAct.Scope <- '? ';
	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );
}

ActionDomain searchActionDomainInTriggerScript( DialogueScript dialogueScript )
{
	ScriptInfoItems scriptInfoItems;
	int infoSize;
	int infoPosition;
	ScriptInfoItem scriptInfoItem;

	scriptInfoItems <- dialogueScript.ScriptInfoItems;
	infoSize <- BatchSize( scriptInfoItems );

	for (infoPosition <- 1; infoPosition <= infoSize; infoPosition ++) 
	{
		BatchRecoverPosition( scriptInfoItems, infoPosition, scriptInfoItem );

		if (scriptInfoItem.InfoItemType == 'action') 
		{
			return scriptInfoItem.InfoItemValue.ActionDomain;
		}
	}
}

Scope searchScopeInTriggerScript( DialogueScript dialogueScript )
{
	ScriptInfoItems scriptInfoItems;
	int infoSize;
	int infoPosition;
	ScriptInfoItem scriptInfoItem;

	scriptInfoItems <- dialogueScript.ScriptInfoItems;
	infoSize <- BatchSize( scriptInfoItems );

	for (infoPosition <- 1; infoPosition <= infoSize; infoPosition ++) 
	{
		BatchRecoverPosition( scriptInfoItems, infoPosition, scriptInfoItem );

		if (scriptInfoItem.InfoItemType == 'scope') 
		{
			return scriptInfoItem.InfoItemValue.Scope;
		}
	}
}

// Aquí hay mucha más casuística:
//	Tener en cuenta puntuación.	
// 	En caso de una racha de empates en puntos separar en dos grupos:
//		seleccionar los autocontenidos mediante un SD
//		seleccionar los no autocontenidos mediante un WD 
procedure processNewActivatedScriptsWithNoScope(int size)
{
	// Step 1: Create the original DigestScheme batch 
	DigestSchemes originalDigestSchemes, selfContainedDigestSchemes, notSelfContainedDigestSchemes;

	for(int i <- 1; i <= size; i++)
	{
		ScriptDescriptor scriptDescriptor;
		DialogueScript dialogueScript;
		
		BatchExtractEnd($MINDBOARD@DialogueState.ActivatedScriptsStack, scriptDescriptor);	
		dialogueScript <- getScript(scriptDescriptor);		

		BatchInsertInit(originalDigestSchemes, dialogueScript.DigestScheme);
	}

	// Step 2: Split recently activated scripts in two batches: selfcontained and not selfcontained
	for(int i <- 1; i <= size; i++)
	{
		DigestScheme digestScheme;
		
		BatchRecoverPosition(originalDigestSchemes, i, digestScheme);	
		if(allDigestChunksCoveredWithEqualPriority(originalDigestSchemes, digestScheme, i))
		{
			BatchInsertInit(selfContainedDigestSchemes, digestScheme);
		}
		else
		{
			BatchInsertInit(notSelfContainedDigestSchemes, digestScheme);
		}
	}

	int sizeOfContained <- BatchSize( selfContainedDigestSchemes );
	int sizeOfNotContained <- BatchSize( notSelfContainedDigestSchemes );

	// Step 3: Add selfcontained to activated scripts stack
	for(int i <- 1; i <= sizeOfContained; i++)
	{
		DigestScheme digestScheme;
		
		BatchRecoverPosition(selfContainedDigestSchemes, i, digestScheme);	
		BatchInsertEnd($MINDBOARD@DialogueState.ActivatedScriptsStack, digestScheme.ScriptDescriptor);		
	}
	
	// Step 4: If there at least 2 scripts create the strong disambiguator
	if(sizeOfContained >= 2)
	{
		pushStrongDisambiguator(sizeOfContained, sizeOfNotContained == 0);
	}

	// Step 5: Add not selfcontained to activated scripts stack
	for(int i <- 1; i <= sizeOfNotContained; i++)
	{
		DigestScheme digestScheme;
		
		BatchRecoverPosition(notSelfContainedDigestSchemes, i, digestScheme);	
		BatchInsertEnd($MINDBOARD@DialogueState.ActivatedScriptsStack, digestScheme.ScriptDescriptor);	
		if(sizeOfNotContained >= 2)	
		{
			DialogueScript dialogueScript <- getScript( digestScheme.ScriptDescriptor );
			dialogueScript <- makeScopeInfoItemCaptured(dialogueScript);
			setScript(dialogueScript);
		}
	}

	// Step 6: If there at least 2 scripts create the weak disambiguator
	if(sizeOfNotContained >= 2)
	{
		pushWeakDisambiguator(sizeOfNotContained, True);
	}
}

DialogueScript createStrongDisambiguator(int size, bool nextToBeActivated)
{
	// Script Descriptor
	DialogueScript dialogueScript;
	string scriptDescriptor <- '';
	scriptDescriptor <- LiteralConcat(scriptDescriptor, 'disambiguator_' );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, 'strong_' );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, ShapeToString(size) );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, '_' );
	scriptDescriptor <- LiteralConcat(scriptDescriptor, ShapeToString(BatchSize($MINDBOARD@DialogueState.ActivatedScriptsStack)) );
	if(nextToBeActivated)
	{
		scriptDescriptor <- LiteralConcat(scriptDescriptor, 'T' );
	}
	else
	{
		scriptDescriptor <- LiteralConcat(scriptDescriptor, 'F' );
	}
	dialogueScript.ScriptDescriptor <- scriptDescriptor;

	// Info
	ScriptInfoItem scriptInfoItem, emptyScriptInfoItem;

	int activatedSize <- BatchSize($MINDBOARD@DialogueState.ActivatedScriptsStack);
	for(int position <- activatedSize - size + 1; position <= activatedSize; position++)
	{	
		BatchRecoverPosition($MINDBOARD@DialogueState.ActivatedScriptsStack, position, scriptDescriptor);

		DialogueScript recoveredDialogueScript <- getScript( scriptDescriptor );

		scriptInfoItem <- emptyScriptInfoItem;
		scriptInfoItem.InfoItemType <- 'action';	
		scriptInfoItem.InfoItemState <- 'empty';	
		scriptInfoItem.InfoItemValue.ActionDomain <- searchActionDomainInTriggerScript(recoveredDialogueScript);
		BatchInsertEnd( dialogueScript.ScriptInfoItems, scriptInfoItem );

		scriptInfoItem <- emptyScriptInfoItem;
		scriptInfoItem.InfoItemType <- 'scope';	
		scriptInfoItem.InfoItemState <- 'empty';	
		scriptInfoItem.InfoItemValue.Scope <- searchScopeInTriggerScript(recoveredDialogueScript);
		BatchInsertEnd( dialogueScript.ScriptInfoItems, scriptInfoItem );
	}

	// Node - AskChoices
	ScriptNode nodeAskChoices <- createScriptNode( 'askchoices', 'wait', 1 );
	nodeAskChoices.ScriptNodeContent <- setNodeContent( 'question', 'choice', '', '' );
	BatchInsertEnd( nodeAskChoices.ScriptNodePreconditions, createNegatedPrecondition2Arguments( 'is_node_state', 'askchoices', 'finalized' ));
	BatchInsertEnd( nodeAskChoices.ScriptNodePostconditions, createDialogueAction0Arguments( 'generate_sd_choices' ));	
	BatchInsertEnd( nodeAskChoices.ScriptNodePostconditions, createDialogueAction2Arguments( 'set_node_state', 'askchoices', 'finalized' ));	

	BatchInsertEnd( dialogueScript.ScriptNodes, nodeAskChoices );

	// Node - MakeChoices
	ScriptNode nodeMakeChoices <- createScriptNode( 'makechoices', 'execute', 2 );
	BatchInsertEnd( nodeMakeChoices.ScriptNodePreconditions, createNegatedPrecondition2Arguments( 'is_node_state', 'makechoices', 'finalized' ));
	BatchInsertEnd( nodeMakeChoices.ScriptNodePostconditions, createDialogueAction0Arguments( 'make_sd_choices' ));	
	BatchInsertEnd( nodeMakeChoices.ScriptNodePostconditions, createDialogueAction2Arguments( 'set_node_state', 'makechoices', 'finalized' ));	
	
	BatchInsertEnd( dialogueScript.ScriptNodes, nodeMakeChoices );

	return dialogueScript;
}


procedure makeStrongDisambiguatorChoices()
{
	int maxScore <- 0;
	int maxPosition;

	ScriptInfoItem scriptInfoItem1, scriptInfoItem2;
	DialogueAct dialogueAct, emptyDialogueAct;
	DialogueScript script <- getCurrentScript();
	
	int size <- BatchSize(script.ScriptInfoItems);
	int position;
	for(position <- 1; position <= size; position <- position + 2)
	{
		BatchRecoverPosition( script.ScriptInfoItems, position , scriptInfoItem1 );
		BatchRecoverPosition( script.ScriptInfoItems, position + 1, scriptInfoItem2 );				

		int currentScore <- 0;
		if(scriptInfoItem1.InfoItemState == 'captured')
		{
			currentScore <- currentScore + 1;
		}
		if(scriptInfoItem2.InfoItemState == 'captured')
		{
			currentScore <- currentScore + 2;
		}
		if(currentScore >= maxScore)
		{
			maxScore <- currentScore;
			maxPosition <- (position + 1) / 2;
		}
	}
	int numChoices <- position / 2;

	// Detect ordinals in not digested proferences zone (when they are implemented)
	if(maxScore == 0 && hasBeenOrdinal())
	{
		Ordinal ordinal <- getLastOrdinal();

		if(!! ordinal.OrdinalReverseFlag)
		{
			maxPosition <- ordinal.NumberValue;
		}
		else
		{
			maxPosition <- numChoices - ordinal.NumberValue + 1;
		}

		if(maxPosition >= 1 && maxPosition <= numChoices)
		{
			maxScore <- 1;
		}
	}

	if(maxScore == 0)
	{
		dialogueAct <- emptyDialogueAct;

		dialogueAct.CoreDialogueAct.Dimension <- 'statement';
		dialogueAct.CoreDialogueAct.Function <- 'inform';
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'cancel' );
		dialogueAct.TaskDialogueAct.Scope <- 'disambiguator';

		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

		string descriptor;
		BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
		DialogueScript recoveredDialogueScript <- removeFromWorkingDialogueScheme( descriptor );

		for(position <- 1; position <= numChoices; position++ )
		{
			BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
			recoveredDialogueScript <- removeFromWorkingDialogueScheme( descriptor );
				
			recoveredDialogueScript <- getFromOriginalDialogueScheme( descriptor );
			BatchInsertEnd( $MINDBOARD@WorkingDialogueScheme.DialogueScripts, recoveredDialogueScript );
		}
	}
	else
	{
		// Pull own script
		string descriptor;
		BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
		DialogueScript recoveredDialogueScript <- removeFromWorkingDialogueScheme( descriptor );

		// pull the rest of the scripts but saves the one in maxPosition
		ActivatedScriptsStack choices;
		ScriptDescriptor selectedScriptDescriptor;
		for(int i <- 1; i <= numChoices; i++)
		{
			BatchExtractEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, descriptor );
			if(i == numChoices + 1 - maxPosition)
			{
				selectedScriptDescriptor <- descriptor;
			}
		}

		// push to the top the script in maxPosition
		BatchInsertEnd( $MINDBOARD@DialogueState.ActivatedScriptsStack, selectedScriptDescriptor );
		
		DialogueScript dialogueScript <- getScript( selectedScriptDescriptor );
		dialogueScript <- makeScopeInfoItemCaptured(dialogueScript);

		setScript(dialogueScript);
	}
}

DialogueScript makeScopeInfoItemCaptured(DialogueScript dialogueScript)
{
	DialogueScript ret <- dialogueScript;
	ScriptInfoItem scriptInfoItem;

	BatchRecoverPosition(ret.ScriptInfoItems, 3, scriptInfoItem);
	scriptInfoItem.InfoItemMoveState <- 'captured';
	BatchAssignPosition(ret.ScriptInfoItems, 3, scriptInfoItem);

	return ret;
}

procedure generateStrongDisambiguatorChoices()
{
	ScriptInfoItem scriptInfoItem1, scriptInfoItem2;
	DialogueAct dialogueAct, emptyDialogueAct;
	DialogueScript script <- getCurrentScript();
	
	if(LiteralPositionValue(script.ScriptDescriptor, LiteralSize(script.ScriptDescriptor)) == 'F')
	{
		dialogueAct <- emptyDialogueAct;

		dialogueAct.CoreDialogueAct.Dimension <- 'statement';
		dialogueAct.CoreDialogueAct.Function <- 'inform';
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'resume' );
		dialogueAct.TaskDialogueAct.Scope <- 'previousproference';

		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );
	}
	
	dialogueAct <- emptyDialogueAct;

	dialogueAct.CoreDialogueAct.Dimension <- 'statement';
	dialogueAct.CoreDialogueAct.Function <- 'inform';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'choose' );
	dialogueAct.TaskDialogueAct.Scope <- 'alternatives';

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

	int size <- BatchSize(script.ScriptInfoItems);

	for(int position <- 1; position <= size - 2 ; position <- position + 2)
	{
		BatchRecoverPosition( script.ScriptInfoItems, position , scriptInfoItem1 );
		BatchRecoverPosition( script.ScriptInfoItems, position + 1, scriptInfoItem2 );				

		dialogueAct <- emptyDialogueAct;
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'tell' );
		dialogueAct.TaskDialogueAct.Scope <- ', ';
		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

		dialogueAct <- emptyDialogueAct;
		dialogueAct.CoreDialogueAct.Dimension <- 'question'; 
		dialogueAct.CoreDialogueAct.Function <- 'choice';
		BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, scriptInfoItem1.InfoItemValue.ActionDomain );
		dialogueAct.TaskDialogueAct.Scope <- scriptInfoItem2.InfoItemValue.Scope;
		BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );
	}

	BatchRecoverPosition( script.ScriptInfoItems, size - 1 , scriptInfoItem1 );
	BatchRecoverPosition( script.ScriptInfoItems, size, scriptInfoItem2 );				

	dialogueAct <- emptyDialogueAct;

	dialogueAct.CoreDialogueAct.Dimension <- 'statement';
	dialogueAct.CoreDialogueAct.Function <- 'inform';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'say' );
	dialogueAct.TaskDialogueAct.Scope <- 'or';

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

	dialogueAct <- emptyDialogueAct;
	dialogueAct.CoreDialogueAct.Dimension <- 'question'; 
	dialogueAct.CoreDialogueAct.Function <- 'choice';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, scriptInfoItem1.InfoItemValue.ActionDomain );
	dialogueAct.TaskDialogueAct.Scope <- scriptInfoItem2.InfoItemValue.Scope;
	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );

	dialogueAct <- emptyDialogueAct;

	dialogueAct.CoreDialogueAct.Dimension <- 'question';
	dialogueAct.CoreDialogueAct.Function <- 'whquestion';
	BatchInsertEnd( dialogueAct.TaskDialogueAct.Action, 'say' );
	dialogueAct.TaskDialogueAct.Scope <- 'prefer';

	BatchInsertEnd( $MINDBOARD@DialogueOutput.DialogueActs, dialogueAct );
}

