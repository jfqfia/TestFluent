// **************************************************
//
//	Rules for dates in english.
//
// **************************************************
// 
//	PROJECT	:	Fluency
//	MODULE  :	Kernel
//	PACKAGE	:	Understanding.English.Grammar
//	FILE	:	DateEnglishGrammar.lkt
// 
// **************************************************

// TODO I think this should be in another file
// If we detect a DateTime in the loneliness
(DateRule01_1 :
    	[ DialogueAct -> DateTime ] 
	{
		^.CoreDialogueAct.Dimension <- 'statement';
		^.CoreDialogueAct.Function <- 'inform';
		^.SemanticContent.Parameters.DateTime <- #1;
    	}
)

(DateRule01_2 :
    	[ DateTime -> OffsetDate ] 
	{
		^.OffsetDate <- #1;
    	}
)

(DateRule01_3 :
    	[ DateTime -> BaseDate ] 
	{
		^.BaseDate <- #1;
    	}
)

// today
// tomorrow
// yesterday
// this day
// now
// after today
// after tomorrow
// after yesterday
// after this day
// after now
// next to this day
(DateRule02 :
    	[ OffsetDate -> lexTemporalModifier? lexOffsetDay ] 
	{
		if(#1)
		{
			if(#1 + #2 < 0)
			{
				^.Date.Day <- -(#1 + #2);
				^.DirectionOfTime <- 'backward';
			}
			else if(#1 + #2 > 0)
			{
				^.Date.Day <- #1 + #2;
				^.DirectionOfTime <- 'forward';	
			}
		}
		else
		{
			if(#2 < 0)
			{
				^.Date.Day <- -#2;
				^.DirectionOfTime <- 'backward';
			}
			else if(#2 > 0)
			{
				^.Date.Day <- #2;
				^.DirectionOfTime <- 'forward';	
			}
		}
    	}
)

// in 4 days
// in 1 day
// 4 days
// 1 day
// within 2 days
(DateRule04_1 :
    	[ OffsetDate -> lexPrepIn? lexNumberDigits lexDayTerm ] 
	{
		^.Date.Day <- #2;
		^.DirectionOfTime <- 'forward';
    	}
)

// in 2 mondays
(DateRule04_2 :
    	[ OffsetDate -> lexPrepIn? lexNumberDigits lexDayInWeek ] 
	{
		^.Date.DayInWeek <- #3;
		^.DayInWeekOffset <- #2;
		^.DirectionOfTime <- 'forward';    	
	}
)

// in 2 weeks
(DateRule04_3 :
    	[ OffsetDate -> lexPrepIn? lexNumberDigits lexWeekTerm ] 
	{
		^.Date.Week <- #2;
		^.DirectionOfTime <- 'forward';    	
	}
)

// in 2 months
(DateRule04_4 :
    	[ OffsetDate -> lexPrepIn? lexNumberDigits lexMonthTerm ] 
	{
		^.Date.Month <- #2;
		^.DirectionOfTime <- 'forward';    	
	}
)

// in 2 years
(DateRule04_5 :
    	[ OffsetDate -> lexPrepIn? lexNumberDigits lexYearTerm ] 
	{
		^.Date.Year <- #2;
		^.DirectionOfTime <- 'forward';    	
	}
)

// next day
// following day
(DateRule05_1 :
    	[ OffsetDate -> lexTemporalModifier lexDayTerm ] 
	{
		if(#1 > 0)
		{
			^.Date.Day <- #1;
			^.DirectionOfTime <- 'forward';    	
		}
		else if(#1 < 0)
		{
			^.Date.Day <- -#1;
			^.DirectionOfTime <- 'backward';    	
		}
    	}
)

// on monday
// next monday
// last monday
// following monday
(DateRule05_2 :
    	[ OffsetDate -> lexTemporalModifier lexDayInWeek ] 
	{
		if(#1 > 0)
		{
			^.Date.DayInWeek <- #2;
			^.DayInWeekOffset <- #1;
			^.DirectionOfTime <- 'forward';    			
		}
		else if(#1 < 0)
		{
			^.Date.DayInWeek <- #2;
			^.DayInWeekOffset <- -#1;
			^.DirectionOfTime <- 'backward';    	
		}
    	}
)

// next week
// last week
(DateRule05_3 :
    	[ OffsetDate -> lexTemporalModifier lexWeekTerm ] 
	{
		if(#1 > 0)
		{
			^.Date.Week <- #1;
			^.DirectionOfTime <- 'forward';    	    	
		}
		else if(#1 < 0)
		{
			^.Date.Week <- -#1;
			^.DirectionOfTime <- 'backward';    	    	
		}
	}
)

// next month
// last month
(DateRule05_4 :
    	[ OffsetDate -> lexTemporalModifier lexMonthTerm ] 
	{
		if(#1 > 0)
		{
			^.Date.Month <- #1;
			^.DirectionOfTime <- 'forward';    	    	
		}
		else if(#1 < 0)
		{
			^.Date.Month <- -#1;
			^.DirectionOfTime <- 'backward';    	    	
		}
    	}
)

// next year
// last year
(DateRule05_5 :
    	[ OffsetDate -> lexTemporalModifier lexYearTerm ] 
	{
		if(#1 > 0)
		{
			^.Date.Year <- #1;
			^.DirectionOfTime <- 'forward';    	    	
		}
		else if(#1 < 0)
		{
			^.Date.Year <- -#1;
			^.DirectionOfTime <- 'backward';    	    	
		}
    	}
)

// from today
// from tomorrow
(DateRule06 :
    	[ OffsetDate -> lexPrepFrom OffsetDate ] 
	{
		^ <- #2;
    	}
)

// next day from tomorrow
// next day from today
// next week from tomorrow
// 1 year and 2 months
// 1 year, 2 months and 3 days ago
(DateRule07 :
    	[ OffsetDate/1 -> OffsetDate/1 lexConjAnd? comma? OffsetDate/0 ] 
	{
		^ <- #1;
		^ <| #4;
		if(#1.Date.Day && #4.Date.Day)
		{
			^.Date.Day <- #1.Date.Day + #4.Date.Day;
		}
		if(#1.Date.Week && #4.Date.Week)
		{
			^.Date.Week <- #1.Date.Week + #4.Date.Week;
		}
		if(#1.Date.Month && #4.Date.Month)
		{
			^.Date.Month <- #1.Date.Month + #4.Date.Month;
		}
		if(#1.Date.Year && #4.Date.Year)
		{
			^.Date.Year <- #1.Date.Year + #4.Date.Year;
		}
    	}
)

// 2 days ago
// 3 days in advance
(DateRule08 :
    	[ OffsetDate -> OffsetDate lexMetaTemporalModifier ] 
	{
		^ <- #1;
		if(#2 > 0)
		{
			^.DirectionOfTime = 'forward';
		}
		else if(#2 < 0)	
		{
			^.DirectionOfTime = 'backward';
		}
    	}
)

// after a couple of weeks
// after next week
// the next day after the next day after tomorrow
(DateRule09 :
    	[ OffsetDate -> lexTemporalModifier OffsetDate ] 
	{
		^ <- #2;
		if(Filled(#2.Date.Day))
		{
			^.Date.Day <- #1 + #2.Date.Day;
		}
		else if(Filled(#2.Date.Week))
		{
			^.Date.Week <- #1 + #2.Date.Week;
		}
		else if(Filled(#2.Date.Month))
		{
			^.Date.Month <- #1 + #2.Date.Month;
		}
		else if(Filled(#2.Date.Year))
		{
			^.Date.Year <- #1 + #2.Date.Year;
		}
		else
		{
			^.Date.Day <- #1;
		}
    	}
)

// this monday
// in 2 mondays
// 3 tuesdays ago
// 2 days before
(DateRule10 :
    	[ OffsetDate -> lexDetThis lexDayInWeek ] 
	{
		^.Date.DayInWeek <- #2;
		^.DayInWeekOffset <- 1;
		^.DirectionOfTime <- 'forward';    	
    	}
)

// august the 1st 1999
// august 1st 1999
// august 1 1999
// august the 1 1999
// august the 1st
// august 1st
// august 1
// august the 1
// august 1, 2016
(DateRule11 :
	[ BaseDate -> lexBaseMonth lexDetThe? <lexBaseDay | lexNumberDigits> comma? lexNumberDigits? ]
	{
	        ^.Day <- #3;
        	^.Month <- #1;
		if(IntegerLength(#5) == 4)
		{
        		^.Year <- #5;
		}
	}
)

// the 1st of august 2016
// the 1st of august 
// the 1st august 2016
// the 1st august 
// the 1 of august 2016
// the 1 of august 
// the 1 august 2016
// the 1 august 
// 1st of august 2016
// 1st of august 
// 1st august 2016
// 1st august 
// 1 of august 2016
// 1 of august 
// 1 august 2016
// 1 august 
(DateRule12 :
	[ BaseDate -> lexDetThe? <lexBaseDay | lexNumberDigits> lexPrepOf? lexBaseMonth lexNumberDigits? ]
	{
	        ^.Day <- #2;
        	^.Month <- #4;
		if(IntegerLength(#5) == 4)
		{
	        	^.Year <- #5;
		}
    	}
)

// in march 2010
// in march
(DateRule13 :
	[ BaseDate -> lexPrepIn? lexBaseMonth lexNumberDigits?]
	{
		^.Month <- #2;
		if(IntegerLength(#3) == 4)
		{
			^.Year <- #3;
		}
	}
)

// in 2016
(DateRule13 :
	[ BaseDate -> lexPrepIn? lexNumberDigits]
	{
		if(IntegerLength(#2) == 4)
		{
			^.Year <- #2;
		}
		else
		{
			Fail();
		}
	}
)

// from 25 of august
(DateRule14 :
	[ BaseDate -> lexPrepFrom BaseDate ]
	{
		^ <- #2;
	}
)

// TODO Should we add 1 day offset?
// following from 25 of august
// after 25 of august
(DateRule15 :
	[ BaseDate -> lexTemporalModifier BaseDate ]
	{
		if(#1 >= 0)
		{	
			^ <- #2;
		}
		else
		{
			Fail();
		}
	}
)

// next day from 25 of august
(DateRule16 :
	[ DateTime -> OffsetDate BaseDate ]
	{
		^.OffsetDate <- #1;
		^.BaseDate <- #2;
	}
)

// TODO Should we add -1 day offset (in case of before)?
// before 25 of august
// until 25 of august
// till 25 aug
// at most until 25 aug
// deadline 25 aug
// to 25 aug
(DateRule17 :
	[ DateTime/1 -> < lexTemporalLimit | lexPrepTo > DateTime/0 ]
	{
		^.MaxDate <- #2;
	}
)

// not on 25 december
(DateRule18 :
	[ DateTime -> lexNegateDate DateTime ]
	{
		^.NegatedDate <- #2;
	}
)

// tomorrow and the day after tomorrow
// 2016 and 2017
// 25 of august and 26 of august and 25 dec
(DateRule19 :
	[ DateTime -> DateTime lexConjAnd DateTime ]
	{
		if(BatchSize(#1.ConjunctionDates) == 0)
		{
			BatchInsertEnd(^.ConjunctionDates, #1);
		}
		else
		{
			^.ConjunctionDates <- #1.ConjunctionDates;
		}
		if(BatchSize(#3.ConjunctionDates) == 0)
		{
			BatchInsertEnd(^.ConjunctionDates, #3);
		}
		else
		{
			^.ConjunctionDates <| #3.ConjunctionDates;
		}
	}
)

// today or tomorrow 
// today or tomorrow or 25 aug
(DateRule20 :
	[ DateTime -> DateTime lexConjOr DateTime ]
	{	
		if(BatchSize(#1.DisjunctionDates) == 0)
		{
			BatchInsertEnd(^.DisjunctionDates, #1);
		}
		else
		{
			^.DisjunctionDates <- #1.DisjunctionDates;
		}
		if(BatchSize(#3.DisjunctionDates) == 0)
		{
			BatchInsertEnd(^.DisjunctionDates, #3);
		}
		else
		{
			^.DisjunctionDates <| #3.DisjunctionDates;
		}
	}
)

// from now until next day after 25 aug
// from now until the day after tomorrow
// from yesterday until the day after tomorrow
(DateRule21 :
	[ DateTime/1 -> DateTime/0 DateTime/1 ]
	{
		if(!!(Filled(#1.NegatedDate) && Filled(#2.NegatedDate)))
		{
			^ <- #1;
			^ <| #2;
		}
	}
)

// TODO nor today nor tomorrow
// until tomorrow has some ambiguity, how can I resolve it?





